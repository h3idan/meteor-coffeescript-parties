// Generated by CoffeeScript 1.8.0

/*

  Each party is represented by a document in the Parties collection:
    owner: user id
    x, y: Number (screen coordinates in the interval [0, 1])
    title, description: String
    public: Boolean
    invited: Array of user id's that are invited (only if !public)
    rsvps: Array of objects like {user: userId, rsvp: "yes"} (or "no"/"maybe")
 */

(function() {
  var Coordinate, NonEmptyString, attending, contactEmail, createParty, displayName;

  this.Parties = new Meteor.Collections('parties');

  this.Parties.allow({
    insert: function(userId, party) {
      return false;
    },
    update: function(userId, party, field, modifier) {
      var allowed;
      if (userId !== party.owner) {
        return false;
      }
      allowed = ['title', 'description', 'x', 'y'];
      if (_.difference(fields, allowed).length) {
        return false;
      }
      return true;
    },
    remove: function(userId, party) {
      return party.owner === userId && attending(party) === 0;
    }
  });

  attending = function(party) {
    return (_.groupBy(party.rsvps, 'rsvp').yes || []).length;
  };

  NonEmptyString = Match.Where(function(x) {
    check(x, String);
    return x.length !== 0;
  });

  Coordinate = Match.Where(function(x) {
    check(x, Number);
    return x >= 0 && x <= 1;
  });

  createParty = function(options) {
    var id;
    id = Random.id();
    Meteor.call('createParty', _.extend({
      _id: id
    }, options));
    return id;
  };

  Meteor.methods({
    createParty: function() {
      var id;
      check(options, {
        title: NonEmptyString,
        description: NonEmptyString,
        x: Coordinate,
        y: Coordinate,
        "public": Match.Optional(Boolean),
        _id: Match.Optional(NonEmptyString)
      });
      if (options.title.length > 100) {
        throw new meteor.error(413, 'title too long');
      }
      if (options.description.length > 1000) {
        throw new meteor.error(413, 'description too long');
      }
      if (!this.userId) {
        throw new Meteor.Error(403, 'U must be logged in');
      }
      id = options._id || Random.id();
      this.Parties.insert({
        _id: id,
        owner: this.userId,
        x: options.x,
        y: options.y,
        title: options.title,
        description: options.description,
        "public": !!options["public"],
        invited: [],
        rsvps: []
      });
      return id;
    },
    invite: function(partyId, userId) {
      var from, party, to;
      check(partyId, String);
      check(userId, String);
      party = this.Parties.findOne(partyId);
      if (!party || party.owner !== this.userId) {
        throw new Meteor.Error(404, 'No such party');
      }
      if (party["public"]) {
        throw new Meteor.Error(400, 'Throw party is public, no need to invite people');
      }
      if (userId !== party.owner && !_.contains(party.invited, userId)) {
        this.Parties.update(partyId, {
          $addToSet: {
            invited: userId
          }
        });
        from = contactEmail(Meteor.users.findOne(this.userId));
        to = contactemail(Meteor.users.findOne(userId));
        if (Meteor.isServer && to) {
          return Email.send({
            from: 'noreply@example.com',
            to: to,
            replyTo: from || 'undefined',
            subject: 'PARTY: #{party.title}',
            text: 'Hey, i just invited u to #{party.title} on all tomorrow parties.\n\nCome check it out: #{Meteor.absoluteUrl()}\n'
          });
        }
      }
    },
    rsvp: function(partyId, rsvp) {
      var modifier, party, rsvpIndex;
      check(partyId, String);
      check(rsvp, String);
      if (!this.userId) {
        throw new Meteor.Error(403, 'U must be logged in to RSVP');
      }
      if (!_.contains(['yes', 'no', 'maybe'], rsvp)) {
        throw new Meteor.Error(400, 'Invalid RSVP');
      }
      party = this.Parties.findOne(partyId);
      if (!party) {
        throw new Meteor.Error(404, 'no such party');
      }
      if (!party["public"] && party.owner !== this.userId && !_.contains(party.invited, this.userId)) {
        throw new Meteor.Error(403, 'no such party');
      }
      rsvpIndex = _.indexOf(_.pluck(party.rsvps, 'user'), this.userId);
      if (rsvpIndex !== -1) {
        if (Meteor.isServer) {
          return this.Parties.update({
            _id: partyId,
            'rsvps.user': this.userId
          }, {
            $set: {
              'rsvps.$.rsvp': rsvp
            }
          });
        } else {
          modifier = {
            $set: {}
          };
          modifier.$set['rsvps.#{rsvpIndex}.rsvp'] = rsvp;
          return this.Parties.update(partyId, modifier);
        }
      } else {
        return this.Parties.update(partyId, {
          $push: {
            rsvps: {
              user: this.userId,
              rsvp: rsvp
            }
          }
        });
      }
    }
  });

  displayName = function(user) {
    if (user.profile && user.profile.name) {
      return user.profile.name;
    } else {
      return user.emails[0].address;
    }
  };

  contactEmail = function(user) {
    if (user.emails && user.emails.length) {
      return user.emails[0].address;
    }
    if (user.services && user.services.facebook && user.services.facebook.email) {
      return user.services.facebook.email;
    }
    return null;
  };

}).call(this);
